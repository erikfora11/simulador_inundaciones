<!DOCTYPE html><html lang="es"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Inundaciones Mejorado</title>
    <style>:root {
  --primary-bg: linear-gradient(135deg, #1a2a6c, #2a4365, #1c3f60);
  --card-bg: #1e3264b3;
  --highlight: #4dccff;
  --danger: #ff6b6b;
  --warning: #ffd166;
  --success: #2ecc71;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: var(--primary-bg);
  color: #f0f8ff;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
  font-family: Segoe UI, Tahoma, Geneva, Verdana, sans-serif;
  display: flex;
  overflow-x: hidden;
}

.header {
  text-align: center;
  width: 100%;
  max-width: 900px;
  margin-bottom: 20px;
}

h1 {
  color: #fff;
  text-shadow: 0 2px 4px #0000004d;
  margin-bottom: 10px;
  font-size: 2.2rem;
}

.subtitle {
  color: #a8d0e6;
  max-width: 700px;
  margin: 0 auto 20px;
  font-size: 1.1rem;
}

.main-container {
  flex-wrap: wrap;
  justify-content: center;
  align-items: flex-start;
  gap: 25px;
  width: 100%;
  max-width: 1000px;
  display: flex;
}

.canvas-container {
  background: #1a2a6c;
  border: 2px solid #3a6ea5;
  border-radius: 8px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 8px 25px #0006;
}

canvas {
  image-rendering: -moz-crisp-edges;
  image-rendering: pixelated;
  display: block;
}

.controls {
  background: var(--card-bg);
  backdrop-filter: blur(5px);
  border-radius: 10px;
  flex-wrap: wrap;
  align-items: center;
  gap: 20px;
  width: 100%;
  max-width: 900px;
  margin-top: 20px;
  padding: 20px;
  display: flex;
  box-shadow: 0 4px 15px #0000004d;
}

.control-group {
  color: #e6f7ff;
  flex-direction: column;
  flex: 1;
  align-items: flex-start;
  min-width: 200px;
  font-size: .95em;
  display: flex;
}

.control-group label {
  justify-content: space-between;
  width: 100%;
  margin-bottom: 8px;
  font-weight: 500;
  display: flex;
}

.control-value {
  color: var(--highlight);
  font-weight: bold;
}

.controls input[type="range"] {
  appearance: none;
  background: #2c3e6d;
  border-radius: 4px;
  outline: none;
  width: 100%;
  height: 8px;
}

.controls input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  background: var(--highlight);
  cursor: pointer;
  border-radius: 50%;
  width: 20px;
  height: 20px;
  box-shadow: 0 2px 5px #0000004d;
}

.button-group {
  gap: 12px;
  margin-top: 10px;
  display: flex;
}

.controls button {
  background: linear-gradient(to bottom, var(--highlight), #2a8fd6);
  color: #fff;
  cursor: pointer;
  border: none;
  border-radius: 6px;
  align-items: center;
  gap: 8px;
  padding: 12px 25px;
  font-size: 1em;
  font-weight: 600;
  transition: all .2s;
  display: flex;
  box-shadow: 0 4px 6px #0003;
}

.controls button:hover {
  background: linear-gradient(#6ddcff, #3a9fe6);
  transform: translateY(-2px);
  box-shadow: 0 6px 8px #00000040;
}

.controls button:active {
  transform: translateY(0);
  box-shadow: 0 2px 4px #0003;
}

.controls button.stop {
  background: linear-gradient(to bottom, var(--danger), #e64a4a);
}

.controls button.stop:hover {
  background: linear-gradient(#ff8b8b, #ff6a6a);
}

.controls button.reset {
  background: linear-gradient(to bottom, var(--warning), #ffb347);
  color: #333;
}

.controls button.reset:hover {
  background: linear-gradient(#ffe186, #ffc266);
}

.info {
  color: #a8d0e6;
  text-align: center;
  background: #1e326480;
  border-radius: 8px;
  max-width: 900px;
  margin-top: 15px;
  padding: 12px 20px;
  font-size: .9em;
  line-height: 1.5;
}

.visualization-options {
  background: var(--card-bg);
  backdrop-filter: blur(5px);
  border-radius: 10px;
  flex-direction: column;
  align-items: flex-start;
  gap: 12px;
  width: 100%;
  max-width: 900px;
  margin-top: 20px;
  padding: 20px;
  display: flex;
  box-shadow: 0 4px 15px #0000004d;
}

.visualization-options h3 {
  color: #fff;
  margin: 0 0 12px;
  font-size: 1.2em;
}

.option-group {
  flex-wrap: wrap;
  gap: 15px;
  display: flex;
}

.visualization-options label {
  color: #e6f7ff;
  cursor: pointer;
  background: #28468299;
  border-radius: 6px;
  align-items: center;
  gap: 10px;
  padding: 8px 15px;
  font-size: .95em;
  transition: all .2s;
  display: flex;
}

.visualization-options label:hover {
  background: #325aa0b3;
}

.visualization-options input[type="radio"] {
  cursor: pointer;
  width: 18px;
  height: 18px;
}

.dashboard {
  background: var(--card-bg);
  backdrop-filter: blur(5px);
  border: 1px solid #3a6ea5;
  border-radius: 10px;
  flex-direction: column;
  flex-shrink: 0;
  width: 300px;
  min-height: 400px;
  padding: 25px;
  display: flex;
  box-shadow: 0 8px 25px #0006;
}

.dashboard h2 {
  color: #fff;
  text-align: center;
  border-bottom: 2px solid var(--highlight);
  margin-top: 0;
  margin-bottom: 20px;
  padding-bottom: 10px;
  font-size: 1.4em;
}

.dashboard p {
  color: #e6f7ff;
  margin-bottom: 15px;
  line-height: 1.6;
}

.dashboard strong {
  color: var(--highlight);
  font-weight: 600;
}

.risk-indicator {
  border-radius: 12px;
  margin-left: 5px;
  padding: 4px 10px;
  font-size: .9em;
  font-weight: bold;
  display: inline-block;
}

.low-risk {
  color: var(--success);
  background-color: #2ecc7133;
}

.moderate-risk {
  color: #f1c40f;
  background-color: #f1c40f33;
}

.high-risk {
  color: #e67e22;
  background-color: #e67e2233;
}

.very-high-risk {
  color: #e74c3c;
  background-color: #e74c3c33;
}

.no-selection {
  text-align: center;
  color: #a8d0e6;
  padding: 20px;
  font-style: italic;
}

.status-bar {
  background: #14285a99;
  border-radius: 8px;
  justify-content: space-between;
  margin-top: 10px;
  padding: 10px 15px;
  font-size: .9em;
  display: flex;
}

.status-item {
  flex-direction: column;
  align-items: center;
  display: flex;
}

.status-value {
  color: var(--highlight);
  margin-top: 3px;
  font-size: 1.2em;
  font-weight: bold;
}

.balance-indicator {
  text-align: center;
  background: #14285a99;
  border-radius: 8px;
  margin-top: 15px;
  padding: 10px;
}

.balance-label {
  margin-bottom: 5px;
  font-size: .9em;
}

.balance-value {
  font-size: 1.2em;
  font-weight: bold;
}

.evaporating {
  color: var(--success);
}

.accumulating {
  color: #e74c3c;
}

.balanced {
  color: #f1c40f;
}

.performance-panel {
  color: #fff;
  z-index: 10;
  background: #0009;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  position: absolute;
  top: 10px;
  right: 10px;
}

@media (width <= 900px) {
  .main-container {
    flex-direction: column;
    align-items: center;
  }

  .dashboard {
    width: 100%;
    min-height: auto;
  }

  .controls, .visualization-options {
    flex-direction: column;
  }

  h1 {
    font-size: 1.8rem;
  }
}

@media (width <= 600px) {
  .option-group, .button-group {
    flex-direction: column;
  }

  .button-group button {
    width: 100%;
  }
}
</style>
</head>
<body>
    <div class="header">
        <h1>Simulador de Riesgos Hidrológicos</h1>
        <p class="subtitle">Monitoreo de inundaciones y derrumbes en tiempo real</p>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <div class="performance-panel">
                FPS: <span id="fpsCounter">0</span>
            </div>
            <canvas id="floodCanvas" width="500" height="500"></canvas>
        </div>

        <div class="dashboard">
            <h2>Información del Asentamiento</h2>
            <div id="noSettlementSelectedMessage" class="no-selection">
                Selecciona un asentamiento en el mapa para ver su información
            </div>
            <div id="settlementInfo" style="display: none">
                <p><strong>Nombre:</strong> <span id="dashboardSettlementName"></span></p>
                <p><strong>Riesgo de Inundación:</strong>
                    <span id="dashboardFloodRisk"></span>
                </p>
                <p><strong>Riesgo de Derrumbe:</strong>
                    <span id="dashboardLandslideRisk"></span>
                </p>
                <p><strong>Altura:</strong> <span id="dashboardHeight"></span> m</p>
                <p><strong>Agua acumulada:</strong> <span id="dashboardWater"></span> m</p>

                <div class="balance-indicator">
                    <div class="balance-label">Balance Agua/Evaporación:</div>
                    <div id="waterBalance" class="balance-value evaporating">Evaporando</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>
                Intensidad de Lluvia
                <span class="control-value" id="rainValue">0.01</span>
            </label>
            <input type="range" id="rainIntensity" min="0" max="1.0" step="0.01" value="0.01">
        </div>

        <div class="control-group">
            <label>
                Tasa de Evaporación
                <span class="control-value" id="evapValue">0.100</span>
            </label>
            <input type="range" id="evaporationRate" min="0" max="0.5" step="0.001" value="0.100">
        </div>

        <div class="button-group">
            <button id="toggleButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
                </svg>
                Iniciar Simulación
            </button>
            <button class="reset" id="resetButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"></path>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"></path>
                </svg>
                Reiniciar
            </button>
        </div>
    </div>

    <div class="visualization-options">
        <h3>Modo de Visualización:</h3>
        <div class="option-group">
            <label>
                <input type="radio" name="viewMode" value="normal" checked="">
                Normal (Terreno y Agua)
            </label>
            <label>
                <input type="radio" name="viewMode" value="floodRisk">
                Riesgo de Inundación
            </label>
            <label>
                <input type="radio" name="viewMode" value="landslideRisk">
                Riesgo de Derrumbe
            </label>
        </div>
    </div>

    <div class="info">
        Haz clic en un asentamiento para ver su información detallada. 
        Los niveles de riesgo se actualizan en tiempo real según las condiciones actuales.
    </div>

    <script>// Obtener el elemento canvas y su contexto 2D
const canvas = document.getElementById('floodCanvas');
const ctx = canvas.getContext('2d');
// Elementos de UI
const toggleButton = document.getElementById('toggleButton');
const resetButton = document.getElementById('resetButton');
const waterBalanceElement = document.getElementById('waterBalance');
const fpsCounter = document.getElementById('fpsCounter');
// Tamaño de la cuadrícula optimizado
const gridSize = 70;
const cellSize = canvas.width / gridSize;
// Arrays 2D para almacenar el estado de la simulación
let terrain = new Array(gridSize);
let water = new Array(gridSize);
let prevWater = new Array(gridSize);
let humidity = new Array(gridSize);
// Pre-inicializar arrays para mejorar rendimiento
for(let i = 0; i < gridSize; i++){
    terrain[i] = new Float32Array(gridSize);
    water[i] = new Float32Array(gridSize);
    prevWater[i] = new Float32Array(gridSize);
    humidity[i] = new Float32Array(gridSize);
}
// Variables para el sistema de evaporación
let timeWithoutRain = 0;
let evaporationMultiplier = 1.0;
const SIGNIFICANT_RAIN_THRESHOLD = 0.01;
const EVAPORATION_BOOST_TIME = 5000;
const MAX_EVAPORATION_MULTIPLIER = 3.0;
// Variables para rastrear el balance agua/evaporación
let totalWater = 0;
let previousTotalWater = 0;
// Asentamientos
let settlements = [];
const MAX_SETTLEMENTS = 12;
// Variable para almacenar el asentamiento seleccionado
let selectedSettlement = null;
// Lista de nombres para los asentamientos
const settlementNames = [
    'Pueblo del Sol',
    'Villa Escondida',
    "R\xedo Claro",
    'Cerro Verde',
    'Puerto Seguro',
    'Valle Feliz',
    'Cima Nevada',
    'Laguna Azul',
    'Bosque Encantado',
    'Pradera Dorada',
    'Piedra Alta',
    'Fuente Serena'
];
let availableNames = [
    ...settlementNames
];
// Variables de control de la simulación
let rainIntensity = parseFloat(document.getElementById('rainIntensity').value);
let evaporationRate = parseFloat(document.getElementById('evaporationRate').value);
const simSpeed = 30;
let simulationInterval = null;
let simulationRunning = false;
let currentViewMode = 'normal';
// Rendimiento
let frameCount = 0;
let lastFpsUpdate = 0;
// --- Implementación de Ruido Perlin (Simplified) ---
const P = new Array(512);
const permutation = [
    ...Array(256).keys()
].sort(()=>Math.random() - 0.5);
for(let i = 0; i < 512; i++)P[i] = permutation[i % 256];
function fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}
function lerp(a, b, t) {
    return a + t * (b - a);
}
function grad(hash, x, y) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}
function perlinNoise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);
    const u = fade(x);
    const v = fade(y);
    const A = P[X] + Y;
    const B = P[X + 1] + Y;
    return lerp(lerp(grad(P[A], x, y), grad(P[B], x - 1, y), u), lerp(grad(P[A + 1], x, y - 1), grad(P[B + 1], x - 1, y - 1), u), v);
}
function octavePerlin(x, y, octaves, persistence) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;
    for(let i = 0; i < octaves; i++){
        total += perlinNoise(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= 2;
    }
    return total / maxValue;
}
// --- Listeners de Eventos para los Controles ---
document.getElementById('rainIntensity').addEventListener('input', (e)=>{
    rainIntensity = parseFloat(e.target.value);
    document.getElementById('rainValue').textContent = rainIntensity.toFixed(2);
});
document.getElementById('evaporationRate').addEventListener('input', (e)=>{
    evaporationRate = parseFloat(e.target.value);
    document.getElementById('evapValue').textContent = evaporationRate.toFixed(3);
});
document.querySelectorAll('input[name="viewMode"]').forEach((radio)=>{
    radio.addEventListener('change', (event)=>{
        currentViewMode = event.target.value;
        drawGrid();
    });
});
// --- Inicialización de la Cuadrícula ---
function initGrid() {
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++){
        const baseScale = 0.02;
        const baseOctaves = 4;
        const basePersistence = 0.5;
        const detailScale = 0.1;
        const detailOctaves = 3;
        const detailPersistence = 0.5;
        let baseHeight = octavePerlin(x * baseScale, y * baseScale, baseOctaves, basePersistence);
        let detailHeight = octavePerlin(x * detailScale, y * detailScale, detailOctaves, detailPersistence);
        baseHeight = (baseHeight + 1) / 2;
        detailHeight = (detailHeight + 1) / 2;
        let combinedHeight = baseHeight * 0.7 + detailHeight * 0.3;
        terrain[y][x] = combinedHeight * 100;
        water[y][x] = 0;
        prevWater[y][x] = 0;
        humidity[y][x] = 1;
    }
    placeRandomSettlements();
    calculateTotalWater();
}
// Función auxiliar para interpolar entre dos colores RGB
function interpolateColor(color1, color2, factor) {
    const result = color1.slice();
    for(let i = 0; i < 3; i++)result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
    return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
}
// Definir paradas de color para la visualización de la altura del terreno
const terrainColorStops = [
    {
        height: 0,
        color: [
            52,
            135,
            52
        ]
    },
    {
        height: 20,
        color: [
            85,
            107,
            47
        ]
    },
    {
        height: 40,
        color: [
            160,
            82,
            45
        ]
    },
    {
        height: 60,
        color: [
            128,
            128,
            128
        ]
    },
    {
        height: 80,
        color: [
            240,
            248,
            255
        ]
    } // Blanco (picos nevados)
];
// --- Dibujo de la Cuadrícula en el Canvas ---
function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++){
        let cellColor = '';
        switch(currentViewMode){
            case 'normal':
                const terrainHeight = terrain[y][x];
                let startColor = terrainColorStops[0].color;
                let endColor = terrainColorStops[0].color;
                let factor = 0;
                for(let i = 0; i < terrainColorStops.length - 1; i++){
                    if (terrainHeight >= terrainColorStops[i].height && terrainHeight <= terrainColorStops[i + 1].height) {
                        startColor = terrainColorStops[i].color;
                        endColor = terrainColorStops[i + 1].color;
                        factor = (terrainHeight - terrainColorStops[i].height) / (terrainColorStops[i + 1].height - terrainColorStops[i].height);
                        break;
                    } else if (terrainHeight > terrainColorStops[terrainColorStops.length - 1].height) {
                        startColor = terrainColorStops[terrainColorStops.length - 1].color;
                        endColor = terrainColorStops[terrainColorStops.length - 1].color;
                        factor = 0;
                        break;
                    }
                }
                cellColor = interpolateColor(startColor, endColor, factor);
                ctx.fillStyle = cellColor;
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                if (water[y][x] > 0.005) {
                    const blueIntensity = Math.floor(100 + Math.min(1, water[y][x] / 15) * 155);
                    const alpha = Math.min(1, water[y][x] / 15) * 0.7;
                    ctx.fillStyle = `rgba(0, 0, ${blueIntensity}, ${alpha})`;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
                break;
            case 'floodRisk':
                let floodRiskColor = '';
                const waterDepth = water[y][x];
                if (waterDepth < 1) floodRiskColor = '#90EE90'; // Verde (bajo riesgo)
                else if (waterDepth < 5) floodRiskColor = '#FFFF00'; // Amarillo (moderado)
                else if (waterDepth < 10) floodRiskColor = '#FFA500'; // Naranja (alto)
                else floodRiskColor = '#FF0000'; // Rojo (muy alto)
                ctx.fillStyle = floodRiskColor;
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                break;
            case 'landslideRisk':
                let landslideRiskColor = '#E0E0E0';
                const currentTerrainHeight = terrain[y][x];
                let maxSlope = 0;
                for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                        const neighborTerrainHeight = terrain[ny][nx];
                        const slope = Math.abs(currentTerrainHeight - neighborTerrainHeight);
                        if (slope > maxSlope) maxSlope = slope;
                    }
                }
                const waterAmount = water[y][x];
                if (waterAmount > 0.1) {
                    const combinedRiskFactor = maxSlope * (1 + waterAmount / 5);
                    if (combinedRiskFactor < 10) landslideRiskColor = '#90EE90'; // Verde (bajo)
                    else if (combinedRiskFactor < 25) landslideRiskColor = '#FFFF00'; // Amarillo (moderado)
                    else if (combinedRiskFactor < 50) landslideRiskColor = '#FFA500'; // Naranja (alto)
                    else landslideRiskColor = '#FF0000'; // Rojo (muy alto)
                }
                ctx.fillStyle = landslideRiskColor;
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                break;
        }
    }
    // MEJORA: Íconos de asentamientos más grandes y visibles
    for (const settlement of settlements){
        const sx = settlement.x;
        const sy = settlement.y;
        const settlementWaterAmount = water[sy][sx];
        let settlementMaxSlope = 0;
        for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){
            if (dx === 0 && dy === 0) continue;
            const nx = sx + dx;
            const ny = sy + dy;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                const neighborTerrainHeight = terrain[ny][nx];
                const slope = Math.abs(terrain[sy][sx] - neighborTerrainHeight);
                if (slope > settlementMaxSlope) settlementMaxSlope = slope;
            }
        }
        const settlementCombinedLandslideRiskFactor = settlementMaxSlope * (1 + settlementWaterAmount / 5);
        // Determinar nivel de riesgo general
        let riskLevel = 'low';
        if (settlementWaterAmount >= 10 || settlementCombinedLandslideRiskFactor >= 50) riskLevel = 'very-high';
        else if (settlementWaterAmount >= 5 || settlementCombinedLandslideRiskFactor >= 25) riskLevel = 'high';
        else if (settlementWaterAmount >= 1 || settlementCombinedLandslideRiskFactor >= 10) riskLevel = 'moderate';
        // Colores según nivel de riesgo
        const colors = {
            'low': '#2ecc71',
            'moderate': '#f1c40f',
            'high': '#e67e22',
            'very-high': '#e74c3c' // Rojo
        };
        const iconColor = colors[riskLevel];
        const isSelected = selectedSettlement && selectedSettlement.x === sx && selectedSettlement.y === sy;
        // MEJORA: Íconos más grandes (de 0.7 a 0.85)
        const iconSize = cellSize * 0.85;
        const centerX = sx * cellSize + cellSize / 2;
        const centerY = sy * cellSize + cellSize / 2;
        // Base de la casa (más grande)
        ctx.fillStyle = iconColor;
        ctx.fillRect(centerX - iconSize / 2, centerY - iconSize / 3, iconSize, iconSize * 0.66);
        // Techo (más grande)
        ctx.beginPath();
        ctx.moveTo(centerX - iconSize / 2, centerY - iconSize / 3);
        ctx.lineTo(centerX, centerY - iconSize / 1.5);
        ctx.lineTo(centerX + iconSize / 2, centerY - iconSize / 3);
        ctx.closePath();
        ctx.fillStyle = '#8B4513'; // Marrón para el techo
        ctx.fill();
        // Ventana (más grande)
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(centerX - iconSize / 4, centerY - iconSize / 6, iconSize / 2, iconSize / 3);
        // Resaltar si está seleccionado (más visible)
        if (isSelected) {
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 3;
            ctx.strokeRect(centerX - iconSize / 2 - 2, centerY - iconSize / 3 - 2, iconSize + 4, iconSize * 0.66 + 4);
        }
        // Nombre del asentamiento (más legible)
        ctx.fillStyle = 'white';
        ctx.font = `bold ${cellSize * 0.22}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(settlement.name, centerX, centerY - iconSize / 1.5 - 5);
    }
}
// --- Lógica de Simulación (Actualización por Paso) ---
function updateSimulation() {
    // Actualizar tiempo sin lluvia
    if (rainIntensity < SIGNIFICANT_RAIN_THRESHOLD) {
        timeWithoutRain += simSpeed;
        if (timeWithoutRain > EVAPORATION_BOOST_TIME) evaporationMultiplier = Math.min(MAX_EVAPORATION_MULTIPLIER, 1.0 + (timeWithoutRain - EVAPORATION_BOOST_TIME) / 10000);
    } else {
        timeWithoutRain = 0;
        evaporationMultiplier = 1.0;
    }
    // Calcular el agua total antes de aplicar cambios
    previousTotalWater = totalWater;
    totalWater = 0;
    // 1. Aplicar lluvia a todas las celdas
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++)water[y][x] += rainIntensity;
    // 2. Aplicar evaporación
    const baseEvaporation = evaporationRate * evaporationMultiplier;
    for(let y = 0; y < gridSize; y++){
        for(let x = 0; x < gridSize; x++)if (water[y][x] > 0) {
            const evaporationFactor = Math.min(1, water[y][x] * 0.1);
            const humidityFactor = (6 - humidity[y][x]) / 5;
            const currentEvaporationAmount = baseEvaporation * humidityFactor * evaporationFactor;
            water[y][x] = Math.max(0, water[y][x] - currentEvaporationAmount);
        }
    }
    // 3. Copiar el estado actual del agua a prevWater
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++)prevWater[y][x] = water[y][x];
    // MEJORA: Flujo de agua más suave con parámetros optimizados
    const K_MIN_SLOPE = 0.001;
    const K_FLOW_RATE = 0.25; // Reducido para menos "jitter"
    const MAX_FLOW_FRACTION = 0.35; // Reducido para flujo más estable
    let waterFlux = Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
    const neighbors = [
        {
            dx: 0,
            dy: -1
        },
        {
            dx: 0,
            dy: 1
        },
        {
            dx: -1,
            dy: 0
        },
        {
            dx: 1,
            dy: 0
        }
    ];
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++){
        if (prevWater[y][x] < K_MIN_SLOPE) continue;
        const currentTotalHeight = terrain[y][x] + prevWater[y][x];
        let totalPossibleFlow = 0;
        let flowDirections = [];
        for (const neighbor of neighbors){
            const nx = x + neighbor.dx;
            const ny = y + neighbor.dy;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                const neighborTotalHeight = terrain[ny][nx] + prevWater[ny][nx];
                const heightDifference = currentTotalHeight - neighborTotalHeight;
                if (heightDifference > K_MIN_SLOPE) {
                    const potentialFlow = heightDifference * K_FLOW_RATE;
                    flowDirections.push({
                        nx,
                        ny,
                        potentialFlow
                    });
                    totalPossibleFlow += potentialFlow;
                }
            }
        }
        if (totalPossibleFlow > 0) {
            const waterToDistribute = Math.min(prevWater[y][x] * MAX_FLOW_FRACTION, prevWater[y][x]);
            for (const flowInfo of flowDirections){
                const actualFlow = flowInfo.potentialFlow / totalPossibleFlow * waterToDistribute;
                waterFlux[flowInfo.ny][flowInfo.nx] += actualFlow;
                waterFlux[y][x] -= actualFlow;
            }
        }
    }
    // Aplicar flujos de agua
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++){
        water[y][x] += waterFlux[y][x];
        water[y][x] = Math.max(0, water[y][x]);
    }
    // 5. Drenaje en los bordes
    const edgeDrainageRate = 0.5;
    const outsideLevel = 0;
    for(let y = 0; y < gridSize; y++){
        for(let x = 0; x < gridSize; x++)if (x === 0 || x === gridSize - 1 || y === 0 || y === gridSize - 1) {
            const cellSurfaceHeight = terrain[y][x] + water[y][x];
            if (cellSurfaceHeight > outsideLevel) {
                let heightDiffAboveOutside = cellSurfaceHeight - outsideLevel;
                let amountToDrain = Math.min(water[y][x], heightDiffAboveOutside * edgeDrainageRate);
                water[y][x] -= amountToDrain;
                water[y][x] = Math.max(0, water[y][x]);
            }
        }
    }
    // MEJORA: Relajación más suave con parámetros optimizados
    const relaxationIterations = 3; // Aumentado para más estabilidad
    const relaxationFactor = 0.03; // Reducido para menos fluctuaciones
    for(let iter = 0; iter < relaxationIterations; iter++){
        let heightChanges = Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
        for(let y = 1; y < gridSize - 1; y++)for(let x = 1; x < gridSize - 1; x++){
            const currentTotalHeight = terrain[y][x] + water[y][x];
            let totalNeighborTotalHeight = 0;
            let activeNeighborsCount = 0;
            const directNeighbors = [
                {
                    dx: 0,
                    dy: -1
                },
                {
                    dx: 0,
                    dy: 1
                },
                {
                    dx: -1,
                    dy: 0
                },
                {
                    dx: 1,
                    dy: 0
                }
            ];
            for (const neighbor of directNeighbors){
                const nx = x + neighbor.dx;
                const ny = y + neighbor.dy;
                const neighborTotalHeight = terrain[ny][nx] + water[ny][nx];
                totalNeighborTotalHeight += neighborTotalHeight;
                activeNeighborsCount++;
            }
            if (activeNeighborsCount > 0) {
                const averageNeighborTotalHeight = totalNeighborTotalHeight / activeNeighborsCount;
                const diff = averageNeighborTotalHeight - currentTotalHeight;
                let transferAmount = diff * relaxationFactor;
                heightChanges[y][x] += transferAmount;
            }
        }
        for(let y = 1; y < gridSize - 1; y++)for(let x = 1; x < gridSize - 1; x++){
            water[y][x] += heightChanges[y][x];
            water[y][x] = Math.max(0, water[y][x]);
        }
    }
    // 7. Actualización de humedad
    const humidityUpdateRate = 0.05;
    for(let y = 0; y < gridSize; y++){
        for(let x = 0; x < gridSize; x++)if (water[y][x] > 0.1) humidity[y][x] = Math.min(5, humidity[y][x] + humidityUpdateRate);
        else humidity[y][x] = Math.max(1, humidity[y][x] - humidityUpdateRate);
    }
    // Update total water
    calculateTotalWater();
    updateWaterBalanceIndicator();
    updateDashboard();
    // Rendimiento: Actualizar contador FPS
    updateFPS();
    drawGrid();
}
// Función para calcular FPS
function updateFPS() {
    const now = performance.now();
    frameCount++;
    if (now >= lastFpsUpdate + 1000) {
        fpsCounter.textContent = frameCount;
        frameCount = 0;
        lastFpsUpdate = now;
    }
}
// Función para calcular el agua total en el sistema
function calculateTotalWater() {
    totalWater = 0;
    for(let y = 0; y < gridSize; y++)for(let x = 0; x < gridSize; x++)totalWater += water[y][x];
}
// Función para actualizar el indicador de balance agua/evaporación
function updateWaterBalanceIndicator() {
    const waterChange = totalWater - previousTotalWater;
    if (waterChange < -0.1) {
        waterBalanceElement.textContent = "Evaporando";
        waterBalanceElement.className = "balance-value evaporating";
    } else if (waterChange > 0.1) {
        waterBalanceElement.textContent = "Acumulando";
        waterBalanceElement.className = "balance-value accumulating";
    } else {
        waterBalanceElement.textContent = "Balanceado";
        waterBalanceElement.className = "balance-value balanced";
    }
}
// --- Funciones para gestionar Asentamientos ---
function getRandomSettlementName() {
    if (availableNames.length === 0) availableNames = [
        ...settlementNames
    ];
    const randomIndex = Math.floor(Math.random() * availableNames.length);
    const name = availableNames[randomIndex];
    availableNames.splice(randomIndex, 1);
    return name;
}
function placeRandomSettlements() {
    settlements = [];
    availableNames = [
        ...settlementNames
    ];
    const maxAttempts = gridSize * gridSize * 2;
    let placedCount = 0;
    for(let i = 0; i < maxAttempts && placedCount < MAX_SETTLEMENTS; i++){
        const x = Math.floor(Math.random() * gridSize);
        const y = Math.floor(Math.random() * gridSize);
        const currentHeight = terrain[y][x];
        const minHeightForSettlement = 15;
        const maxHeightForSettlement = 75;
        if (currentHeight < minHeightForSettlement || currentHeight > maxHeightForSettlement) continue;
        let totalSlope = 0;
        let slopeNeighbors = 0;
        const slopeCheckRadius = 1;
        for(let dy = -slopeCheckRadius; dy <= slopeCheckRadius; dy++)for(let dx = -slopeCheckRadius; dx <= slopeCheckRadius; dx++){
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                totalSlope += Math.abs(currentHeight - terrain[ny][nx]);
                slopeNeighbors++;
            }
        }
        const averageSlope = slopeNeighbors > 0 ? totalSlope / slopeNeighbors : 0;
        const maxAllowedSlope = 10;
        if (averageSlope > maxAllowedSlope) continue;
        let tooClose = false;
        const minDistance = 5;
        for (const existingSettlement of settlements){
            const dist = Math.sqrt(Math.pow(x - existingSettlement.x, 2) + Math.pow(y - existingSettlement.y, 2));
            if (dist < minDistance) {
                tooClose = true;
                break;
            }
        }
        if (tooClose) continue;
        settlements.push({
            x,
            y,
            name: getRandomSettlementName()
        });
        placedCount++;
    }
}
// --- Funciones del Dashboard ---
function updateDashboard() {
    const noSettlementMessage = document.getElementById('noSettlementSelectedMessage');
    const infoDiv = document.getElementById('settlementInfo');
    const nameSpan = document.getElementById('dashboardSettlementName');
    const floodSpan = document.getElementById('dashboardFloodRisk');
    const landslideSpan = document.getElementById('dashboardLandslideRisk');
    const heightSpan = document.getElementById('dashboardHeight');
    const waterSpan = document.getElementById('dashboardWater');
    if (selectedSettlement) {
        noSettlementMessage.style.display = 'none';
        infoDiv.style.display = 'block';
        nameSpan.textContent = selectedSettlement.name;
        const sx = selectedSettlement.x;
        const sy = selectedSettlement.y;
        const settlementWaterAmount = water[sy][sx];
        let settlementMaxSlope = 0;
        for(let dy = -1; dy <= 1; dy++)for(let dx = -1; dx <= 1; dx++){
            if (dx === 0 && dy === 0) continue;
            const nx = sx + dx;
            const ny = sy + dy;
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                const neighborTerrainHeight = terrain[ny][nx];
                const slope = Math.abs(terrain[sy][sx] - neighborTerrainHeight);
                if (slope > settlementMaxSlope) settlementMaxSlope = slope;
            }
        }
        const settlementCombinedLandslideRiskFactor = settlementMaxSlope * (1 + settlementWaterAmount / 5);
        let floodRiskText = 'Bajo';
        let floodRiskClass = 'low-risk';
        if (settlementWaterAmount >= 10) {
            floodRiskText = 'Muy Alto';
            floodRiskClass = 'very-high-risk';
        } else if (settlementWaterAmount >= 5) {
            floodRiskText = 'Alto';
            floodRiskClass = 'high-risk';
        } else if (settlementWaterAmount >= 1) {
            floodRiskText = 'Moderado';
            floodRiskClass = 'moderate-risk';
        }
        floodSpan.textContent = floodRiskText;
        floodSpan.className = `risk-indicator ${floodRiskClass}`;
        let landslideRiskText = 'Bajo';
        let landslideRiskClass = 'low-risk';
        if (settlementCombinedLandslideRiskFactor >= 50) {
            landslideRiskText = 'Muy Alto';
            landslideRiskClass = 'very-high-risk';
        } else if (settlementCombinedLandslideRiskFactor >= 25) {
            landslideRiskText = 'Alto';
            landslideRiskClass = 'high-risk';
        } else if (settlementCombinedLandslideRiskFactor >= 10) {
            landslideRiskText = 'Moderado';
            landslideRiskClass = 'moderate-risk';
        }
        landslideSpan.textContent = landslideRiskText;
        landslideSpan.className = `risk-indicator ${landslideRiskClass}`;
        heightSpan.textContent = terrain[sy][sx].toFixed(1);
        waterSpan.textContent = settlementWaterAmount.toFixed(2);
    } else {
        noSettlementMessage.style.display = 'block';
        infoDiv.style.display = 'none';
    }
}
// --- Interacción del Usuario (Selección de Asentamientos) ---
canvas.addEventListener('click', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    let clickedSettlementFound = false;
    const clickRadius = cellSize * 0.85; // Ajustado al nuevo tamaño de íconos
    for (const settlement of settlements){
        const settlementCenterX = settlement.x * cellSize + cellSize / 2;
        const settlementCenterY = settlement.y * cellSize + cellSize / 2;
        const distance = Math.sqrt(Math.pow(clickX - settlementCenterX, 2) + Math.pow(clickY - settlementCenterY, 2));
        if (distance <= clickRadius) {
            selectedSettlement = settlement;
            clickedSettlementFound = true;
            break;
        }
    }
    if (!clickedSettlementFound) selectedSettlement = null;
    updateDashboard();
    drawGrid();
});
canvas.addEventListener('contextmenu', (e)=>e.preventDefault());
// --- Funciones de Control de la Simulación ---
function toggleSimulation() {
    if (simulationRunning) {
        clearInterval(simulationInterval);
        simulationInterval = null;
        simulationRunning = false;
        toggleButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
                        <path d="m11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                    </svg>
                    Iniciar Simulaci\xf3n
                `;
        toggleButton.classList.remove('stop');
    } else {
        simulationInterval = setInterval(updateSimulation, simSpeed);
        simulationRunning = true;
        toggleButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
                        <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                    </svg>
                    Detener Simulaci\xf3n
                `;
        toggleButton.classList.add('stop');
    }
}
function resetSimulation() {
    if (simulationRunning) toggleSimulation();
    timeWithoutRain = 0;
    evaporationMultiplier = 1.0;
    selectedSettlement = null;
    initGrid();
    drawGrid();
    updateDashboard();
    updateWaterBalanceIndicator();
}
// Configurar eventos
toggleButton.addEventListener('click', toggleSimulation);
resetButton.addEventListener('click', resetSimulation);
// --- Configuración Inicial al Cargar la Página ---
initGrid();
drawGrid();
updateDashboard();
toggleSimulation();

</script>

<script src="/lluvias.3464ddca.js"></script></body></html>