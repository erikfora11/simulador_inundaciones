<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Inundaciones Optimizado</title>
    <style>
        :root {
            --primary-bg: linear-gradient(135deg, #1a2a6c, #2a4365, #1c3f60);
            --card-bg: rgba(30, 50, 100, 0.7);
            --highlight: #4dccff;
            --danger: #ff6b6b;
            --warning: #ffd166;
            --success: #2ecc71;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: var(--primary-bg);
            padding: 20px;
            color: #f0f8ff;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 10px;
            font-size: 2.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: #a8d0e6;
            font-size: 1.1rem;
            max-width: 700px;
            margin: 0 auto 20px;
        }

        .main-container {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            max-width: 1000px;
            width: 100%;
        }

        .canvas-container {
            position: relative;
            background: #1a2a6c;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            border: 2px solid #3a6ea5;
        }

        canvas {
            display: block;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            background: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 900px;
            backdrop-filter: blur(5px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            font-size: 0.95em;
            color: #e6f7ff;
            flex: 1;
            min-width: 200px;
        }

        .control-group label {
            margin-bottom: 8px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .control-value {
            font-weight: bold;
            color: var(--highlight);
        }

        .controls input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2c3e6d;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--highlight);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 10px;
        }

        .controls button {
            padding: 12px 25px;
            background: linear-gradient(to bottom, var(--highlight), #2a8fd6);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .controls button:hover {
            background: linear-gradient(to bottom, #6ddcff, #3a9fe6);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.25);
        }

        .controls button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls button.stop {
            background: linear-gradient(to bottom, var(--danger), #e64a4a);
        }

        .controls button.stop:hover {
            background: linear-gradient(to bottom, #ff8b8b, #ff6a6a);
        }

        .controls button.reset {
            background: linear-gradient(to bottom, var(--warning), #ffb347);
            color: #333;
        }

        .controls button.reset:hover {
            background: linear-gradient(to bottom, #ffe186, #ffc266);
        }

        .info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #a8d0e6;
            text-align: center;
            max-width: 900px;
            background: rgba(30, 50, 100, 0.5);
            padding: 12px 20px;
            border-radius: 8px;
            line-height: 1.5;
        }

        .visualization-options {
            margin-top: 20px;
            background: var(--card-bg);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
            width: 100%;
            max-width: 900px;
            backdrop-filter: blur(5px);
        }

        .visualization-options h3 {
            margin: 0 0 12px 0;
            color: #ffffff;
            font-size: 1.2em;
        }

        .option-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .visualization-options label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95em;
            color: #e6f7ff;
            padding: 8px 15px;
            background: rgba(40, 70, 130, 0.6);
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .visualization-options label:hover {
            background: rgba(50, 90, 160, 0.7);
        }

        .visualization-options input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .dashboard {
            background: var(--card-bg);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 300px;
            flex-shrink: 0;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(5px);
            border: 1px solid #3a6ea5;
        }

        .dashboard h2 {
            color: #ffffff;
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.4em;
            border-bottom: 2px solid var(--highlight);
            padding-bottom: 10px;
        }

        .dashboard p {
            margin-bottom: 15px;
            color: #e6f7ff;
            line-height: 1.6;
        }

        .dashboard strong {
            color: var(--highlight);
            font-weight: 600;
        }

        .risk-indicator {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.9em;
            margin-left: 5px;
        }

        .low-risk {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--success);
        }

        .moderate-risk {
            background-color: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
        }

        .high-risk {
            background-color: rgba(230, 126, 34, 0.2);
            color: #e67e22;
        }

        .very-high-risk {
            background-color: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .no-selection {
            text-align: center;
            padding: 20px;
            color: #a8d0e6;
            font-style: italic;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 10px 15px;
            background: rgba(20, 40, 90, 0.6);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status-value {
            font-weight: bold;
            font-size: 1.2em;
            color: var(--highlight);
            margin-top: 3px;
        }

        .evaporation-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }

        .indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--highlight);
            box-shadow: 0 0 8px var(--highlight);
        }

        .balance-indicator {
            margin-top: 15px;
            padding: 10px;
            background: rgba(20, 40, 90, 0.6);
            border-radius: 8px;
            text-align: center;
        }

        .balance-label {
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .balance-value {
            font-weight: bold;
            font-size: 1.2em;
        }

        .evaporating {
            color: var(--success);
        }

        .accumulating {
            color: #e74c3c;
        }

        .balanced {
            color: #f1c40f;
        }

        .performance-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10;
        }

        .optimization-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 12px;
        }

        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }

            .dashboard {
                width: 100%;
                min-height: auto;
            }

            .controls, .visualization-options {
                flex-direction: column;
            }

            h1 {
                font-size: 1.8rem;
            }
        }

        @media (max-width: 600px) {
            .option-group {
                flex-direction: column;
            }

            .button-group {
                flex-direction: column;
            }

            .button-group button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Simulador de Inundaciones Optimizado</h1>
        <p class="subtitle">Simulación hidrológica con alto rendimiento</p>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <div class="performance-panel">
                FPS: <span id="fpsCounter">0</span> | Celdas: <span id="cellCounter">0</span>
                <div class="optimization-info" id="optimizationStatus">Modo: Normal</div>
            </div>
            <canvas id="floodCanvas" width="500" height="500"></canvas>
        </div>

        <div class="dashboard">
            <h2>Información del Asentamiento</h2>
            <div id="noSettlementSelectedMessage" class="no-selection">
                Selecciona un asentamiento en el mapa para ver su información
            </div>
            <div id="settlementInfo" style="display: none;">
                <p><strong>Nombre:</strong> <span id="dashboardSettlementName"></span></p>
                <p><strong>Riesgo de Inundación:</strong>
                    <span id="dashboardFloodRisk"></span>
                </p>
                <p><strong>Altura:</strong> <span id="dashboardHeight"></span> m</p>
                <p><strong>Agua acumulada:</strong> <span id="dashboardWater"></span> m</p>

                <div class="status-bar">
                    <div class="status-item">
                        <span>Sin lluvia:</span>
                        <span id="noRainTime" class="status-value">0s</span>
                    </div>
                    <div class="status-item">
                        <span>Evaporación:</span>
                        <span id="evaporationStatus" class="status-value">Normal</span>
                    </div>
                </div>

                <div class="evaporation-indicator">
                    <div class="indicator-dot"></div>
                    <span>La evaporación aumenta después de 5s sin lluvia</span>
                </div>

                <div class="balance-indicator">
                    <div class="balance-label">Balance Agua/Evaporación:</div>
                    <div id="waterBalance" class="balance-value evaporating">Evaporando</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>
                Intensidad de Lluvia
                <span class="control-value" id="rainValue">0.01</span>
            </label>
            <input type="range" id="rainIntensity" min="0" max="1.0" step="0.01" value="0.01">
        </div>

        <div class="control-group">
            <label>
                Tasa de Evaporación
                <span class="control-value" id="evapValue">0.100</span>
            </label>
            <input type="range" id="evaporationRate" min="0" max="0.5" step="0.001" value="0.100">
        </div>

        <div class="button-group">
            <button id="toggleButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                </svg>
                Iniciar Simulación
            </button>
            <button class="reset" id="resetButton">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-counterclockwise" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2v1z"/>
                    <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                </svg>
                Reiniciar
            </button>
        </div>
    </div>

    <div class="visualization-options">
        <h3>Modo de Visualización:</h3>
        <div class="option-group">
            <label>
                <input type="radio" name="viewMode" value="normal" checked>
                Normal (Terreno y Agua)
            </label>
            <label>
                <input type="radio" name="viewMode" value="floodRisk">
                Mapa de Riesgos de Inundación
            </label>
        </div>
    </div>

    <div class="info">
        <strong>Optimizaciones activas:</strong> 
        <ul>
            <li>Mapa reducido para mejor rendimiento</li>
            <li>Sistema de evaporación visual eliminado</li>
            <li>Algoritmo de flujo optimizado</li>
            <li>Modo de alta lluvia con cálculos simplificados</li>
        </ul>
    </div>

    <script>
        // Obtener el elemento canvas y su contexto 2D
        const canvas = document.getElementById('floodCanvas');
        const ctx = canvas.getContext('2d');
        
        // Elementos de UI
        const toggleButton = document.getElementById('toggleButton');
        const resetButton = document.getElementById('resetButton');
        const noRainTimeElement = document.getElementById('noRainTime');
        const evaporationStatusElement = document.getElementById('evaporationStatus');
        const waterBalanceElement = document.getElementById('waterBalance');
        const fpsCounter = document.getElementById('fpsCounter');
        const cellCounter = document.getElementById('cellCounter');
        const optimizationStatus = document.getElementById('optimizationStatus');

        // Reducir el tamaño de la cuadrícula para mejorar el rendimiento
        const gridSize = 70;  // Reducido de 100 a 70 (4900 celdas en lugar de 10000)
        const cellSize = canvas.width / gridSize;
        cellCounter.textContent = `${gridSize}x${gridSize}`;

        // Arrays 2D para almacenar el estado de la simulación
        let terrain = new Array(gridSize);
        let water = new Array(gridSize);
        let prevWater = new Array(gridSize);
        let humidity = new Array(gridSize);

        // Pre-inicializar arrays para mejorar rendimiento
        for (let i = 0; i < gridSize; i++) {
            terrain[i] = new Float32Array(gridSize);
            water[i] = new Float32Array(gridSize);
            prevWater[i] = new Float32Array(gridSize);
            humidity[i] = new Float32Array(gridSize);
        }

        // Variables para el sistema de evaporación mejorado
        let timeWithoutRain = 0;
        let evaporationMultiplier = 1.0;
        const SIGNIFICANT_RAIN_THRESHOLD = 0.01;
        const EVAPORATION_BOOST_TIME = 5000;
        const MAX_EVAPORATION_MULTIPLIER = 3.0;

        // Variables para rastrear el balance agua/evaporación
        let totalWater = 0;
        let previousTotalWater = 0;

        // Asentamientos
        let settlements = [];
        const MAX_SETTLEMENTS = 12;

        // Variable para almacenar el asentamiento seleccionado
        let selectedSettlement = null;

        // Lista de nombres para los asentamientos
        const settlementNames = [
            'Pueblo del Sol', 'Villa Escondida', 'Río Claro', 'Cerro Verde', 'Puerto Seguro',
            'Valle Feliz', 'Cima Nevada', 'Laguna Azul', 'Bosque Encantado', 'Pradera Dorada',
            'Piedra Alta', 'Fuente Serena'
        ];
        let availableNames = [...settlementNames];

        // Variables de control de la simulación
        let rainIntensity = parseFloat(document.getElementById('rainIntensity').value);
        let evaporationRate = parseFloat(document.getElementById('evaporationRate').value);
        const simSpeed = 30;

        let simulationInterval = null;
        let simulationRunning = false;
        let currentViewMode = 'normal';

        // Rendimiento
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let optimizationMode = 'normal'; // 'normal' o 'high_rain'

        // --- Implementación de Ruido Perlin (Simplified) ---
        const P = new Array(512);
        const permutation = [...Array(256).keys()].sort(() => Math.random() - 0.5);
        for (let i = 0; i < 512; i++) {
            P[i] = permutation[i % 256];
        }

        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(a, b, t) { return a + t * (b - a); }
        function grad(hash, x, y) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : (h === 12 || h === 14 ? x : 0);
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        function perlinNoise(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;

            x -= Math.floor(x);
            y -= Math.floor(y);

            const u = fade(x);
            const v = fade(y);

            const A = P[X] + Y;
            const B = P[X + 1] + Y;

            return lerp(
                lerp(grad(P[A], x, y), grad(P[B], x - 1, y), u),
                lerp(grad(P[A + 1], x, y - 1), grad(P[B + 1], x - 1, y - 1), u),
                v
            );
        }

        function octavePerlin(x, y, octaves, persistence) {
            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                total += perlinNoise(x * frequency, y * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= 2;
            }

            return total / maxValue;
        }

        // --- Listeners de Eventos para los Controles ---
        document.getElementById('rainIntensity').addEventListener('input', (e) => {
            rainIntensity = parseFloat(e.target.value);
            document.getElementById('rainValue').textContent = rainIntensity.toFixed(2);
            
            // Cambiar modo de optimización basado en intensidad de lluvia
            optimizationMode = rainIntensity > 0.3 ? 'high_rain' : 'normal';
            optimizationStatus.textContent = `Modo: ${optimizationMode === 'high_rain' ? 'Alta Lluvia' : 'Normal'}`;
        });

        document.getElementById('evaporationRate').addEventListener('input', (e) => {
            evaporationRate = parseFloat(e.target.value);
            document.getElementById('evapValue').textContent = evaporationRate.toFixed(3);
        });

        document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentViewMode = event.target.value;
                drawGrid();
            });
        });

        // --- Inicialización de la Cuadrícula ---
        function initGrid() {
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const baseScale = 0.02;
                    const baseOctaves = 4;
                    const basePersistence = 0.5;

                    const detailScale = 0.1;
                    const detailOctaves = 3;
                    const detailPersistence = 0.5;

                    let baseHeight = octavePerlin(x * baseScale, y * baseScale, baseOctaves, basePersistence);
                    let detailHeight = octavePerlin(x * detailScale, y * detailScale, detailOctaves, detailPersistence);

                    baseHeight = (baseHeight + 1) / 2;
                    detailHeight = (detailHeight + 1) / 2;

                    let combinedHeight = (baseHeight * 0.7 + detailHeight * 0.3);
                    terrain[y][x] = combinedHeight * 100;
                    water[y][x] = 0;
                    prevWater[y][x] = 0;
                    humidity[y][x] = 1;
                }
            }
            placeRandomSettlements();
            calculateTotalWater();
        }

        // Función auxiliar para interpolar entre dos colores RGB
        function interpolateColor(color1, color2, factor) {
            const result = color1.slice();
            for (let i = 0; i < 3; i++) {
                result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
            }
            return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
        }

        // Definir paradas de color para la visualización de la altura del terreno
        const terrainColorStops = [
            { height: 0, color: [52, 135, 52] },
            { height: 20, color: [85, 107, 47] },
            { height: 40, color: [160, 82, 45] },
            { height: 60, color: [128, 128, 128] },
            { height: 80, color: [240, 248, 255] }
        ];

        // --- Dibujo de la Cuadrícula en el Canvas con LOD ---
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // En modo alta lluvia, simplificamos el dibujo del agua
            const isHighRainMode = optimizationMode === 'high_rain';

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let cellColor = '';

                    switch (currentViewMode) {
                        case 'normal':
                            const terrainHeight = terrain[y][x];
                            let startColor = terrainColorStops[0].color;
                            let endColor = terrainColorStops[0].color;
                            let factor = 0;

                            for (let i = 0; i < terrainColorStops.length - 1; i++) {
                                if (terrainHeight >= terrainColorStops[i].height && terrainHeight <= terrainColorStops[i + 1].height) {
                                    startColor = terrainColorStops[i].color;
                                    endColor = terrainColorStops[i + 1].color;
                                    factor = (terrainHeight - terrainColorStops[i].height) / (terrainColorStops[i + 1].height - terrainColorStops[i].height);
                                    break;
                                } else if (terrainHeight > terrainColorStops[terrainColorStops.length - 1].height) {
                                    startColor = terrainColorStops[terrainColorStops.length - 1].color;
                                    endColor = terrainColorStops[terrainColorStops.length - 1].color;
                                    factor = 0;
                                    break;
                                }
                            }
                            cellColor = interpolateColor(startColor, endColor, factor);
                            ctx.fillStyle = cellColor;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);

                            if (water[y][x] > 0.005) {
                                // En modo alta lluvia, dibujamos un azul más simple
                                if (isHighRainMode) {
                                    const blueIntensity = Math.min(255, 100 + water[y][x] * 10);
                                    const alpha = Math.min(0.7, water[y][x] / 15);
                                    ctx.fillStyle = `rgba(0, 0, ${blueIntensity}, ${alpha})`;
                                } else {
                                    const fullOpacityDepth = 15;
                                    const maxWaterAlpha = 0.7;

                                    const blueIntensity = Math.floor(100 + Math.min(1, water[y][x] / fullOpacityDepth) * 155);
                                    const alpha = Math.min(1, water[y][x] / fullOpacityDepth) * maxWaterAlpha;
                                    ctx.fillStyle = `rgba(0, 0, ${blueIntensity}, ${alpha})`;
                                }
                                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            }
                            break;

                        case 'floodRisk':
                            let floodRiskColor = '';
                            const waterDepth = water[y][x];

                            if (waterDepth < 1) {
                                floodRiskColor = '#90EE90';
                            } else if (waterDepth < 5) {
                                floodRiskColor = '#FFFF00';
                            } else if (waterDepth < 10) {
                                floodRiskColor = '#FFA500';
                            } else {
                                floodRiskColor = '#FF0000';
                            }
                            ctx.fillStyle = floodRiskColor;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                            break;
                    }
                }
            }

            // Dibujar Asentamientos
            for (const settlement of settlements) {
                const sx = settlement.x;
                const sy = settlement.y;

                const settlementWaterAmount = water[sy][sx];
                
                let settlementRiskColor = 'green';
                let symbolSize = cellSize * 0.6;
                let alertLevelText = 'Bajo';

                if (settlementWaterAmount >= 10) {
                    settlementRiskColor = 'red';
                    symbolSize = cellSize * 0.8;
                    alertLevelText = 'Muy Alto';
                } else if (settlementWaterAmount >= 5) {
                    settlementRiskColor = 'orange';
                    symbolSize = cellSize * 0.7;
                    alertLevelText = 'Alto';
                } else if (settlementWaterAmount >= 1) {
                    settlementRiskColor = 'yellow';
                    symbolSize = cellSize * 0.65;
                    alertLevelText = 'Moderado';
                }

                ctx.beginPath();
                ctx.arc(sx * cellSize + cellSize / 2, sy * cellSize + cellSize / 2, symbolSize / 2, 0, Math.PI * 2);
                ctx.fillStyle = settlementRiskColor;
                ctx.fill();

                if (selectedSettlement && selectedSettlement.x === sx && selectedSettlement.y === sy) {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 3;
                } else {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.font = `bold ${cellSize * 0.2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(settlement.name, sx * cellSize + cellSize / 2, sy * cellSize + cellSize / 2 - symbolSize / 2 - 2);

                ctx.fillStyle = settlementRiskColor;
                ctx.font = `bold ${cellSize * 0.25}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(alertLevelText, sx * cellSize + cellSize / 2, sy * cellSize + cellSize / 2 + symbolSize / 2 + 2);

                if (settlementRiskColor === 'red' || settlementRiskColor === 'orange') {
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${symbolSize * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('!', sx * cellSize + cellSize / 2, sy * cellSize + cellSize / 2);
                }
            }
        }

        // --- Lógica de Simulación (Actualización por Paso) ---
        function updateSimulation() {
            // Actualizar tiempo sin lluvia
            if (rainIntensity < SIGNIFICANT_RAIN_THRESHOLD) {
                timeWithoutRain += simSpeed;
                if (timeWithoutRain > EVAPORATION_BOOST_TIME) {
                    evaporationMultiplier = Math.min(MAX_EVAPORATION_MULTIPLIER,
                        1.0 + (timeWithoutRain - EVAPORATION_BOOST_TIME) / 10000);
                }
            } else {
                timeWithoutRain = 0;
                evaporationMultiplier = 1.0;
            }

            // Actualizar UI con información de evaporación
            noRainTimeElement.textContent = (timeWithoutRain / 1000).toFixed(1) + 's';

            if (evaporationMultiplier > 1.0) {
                evaporationStatusElement.textContent = 'Aumentada (' + evaporationMultiplier.toFixed(1) + 'x)';
                evaporationStatusElement.className = 'status-value';
            } else {
                evaporationStatusElement.textContent = 'Normal';
                evaporationStatusElement.className = 'status-value';
            }

            // Calcular el agua total antes de aplicar cambios
            previousTotalWater = totalWater;
            totalWater = 0;

            // 1. Aplicar lluvia a todas las celdas
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    water[y][x] += rainIntensity;
                }
            }

            // 2. Aplicar evaporación optimizada (sin efectos visuales)
            const baseEvaporation = evaporationRate * evaporationMultiplier;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (water[y][x] > 0) {
                        const evaporationFactor = Math.min(1, water[y][x] * 0.1);
                        const humidityFactor = (6 - humidity[y][x]) / 5;
                        const currentEvaporationAmount = baseEvaporation * humidityFactor * evaporationFactor;
                        water[y][x] = Math.max(0, water[y][x] - currentEvaporationAmount);
                    }
                }
            }

            // 3. Copiar el estado actual del agua a prevWater
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    prevWater[y][x] = water[y][x];
                }
            }

            // 4. Optimized Water Flow - ¡Aquí está la optimización principal!
            const K_MIN_SLOPE = 0.001;
            const K_FLOW_RATE = optimizationMode === 'high_rain' ? 0.2 : 0.4;
            const MAX_FLOW_FRACTION = optimizationMode === 'high_rain' ? 0.2 : 0.4;
            let waterFlux = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));

            // Solo vecinos directos (arriba, abajo, izquierda, derecha) - reduce cálculos
            const neighbors = [
                { dx: 0, dy: -1 }, 
                { dx: 0, dy: 1 }, 
                { dx: -1, dy: 0 }, 
                { dx: 1, dy: 0 }
            ];

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (prevWater[y][x] < K_MIN_SLOPE) continue;

                    const currentTotalHeight = terrain[y][x] + prevWater[y][x];
                    let totalPossibleFlow = 0;
                    let flowDirections = [];

                    for (const neighbor of neighbors) {
                        const nx = x + neighbor.dx;
                        const ny = y + neighbor.dy;

                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            const neighborTotalHeight = terrain[ny][nx] + prevWater[ny][nx];
                            const heightDifference = currentTotalHeight - neighborTotalHeight;

                            if (heightDifference > K_MIN_SLOPE) {
                                const potentialFlow = heightDifference * K_FLOW_RATE;
                                flowDirections.push({ nx, ny, potentialFlow });
                                totalPossibleFlow += potentialFlow;
                            }
                        }
                    }

                    if (totalPossibleFlow > 0) {
                        // Limitar la cantidad de agua a mover a una fracción del total disponible
                        const waterToDistribute = Math.min(prevWater[y][x] * MAX_FLOW_FRACTION, prevWater[y][x]);
                        
                        for (const flowInfo of flowDirections) {
                            const actualFlow = (flowInfo.potentialFlow / totalPossibleFlow) * waterToDistribute;
                            waterFlux[flowInfo.ny][flowInfo.nx] += actualFlow;
                            waterFlux[y][x] -= actualFlow;
                        }
                    }
                }
            }

            // Aplicar flujos de agua
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    water[y][x] += waterFlux[y][x];
                    water[y][x] = Math.max(0, water[y][x]);
                }
            }

            // 5. Drenaje en los bordes
            const edgeDrainageRate = 0.5;
            const outsideLevel = 0;

            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (x === 0 || x === gridSize - 1 || y === 0 || y === gridSize - 1) {
                        const cellSurfaceHeight = terrain[y][x] + water[y][x];
                        if (cellSurfaceHeight > outsideLevel) {
                            let heightDiffAboveOutside = cellSurfaceHeight - outsideLevel;
                            let amountToDrain = Math.min(water[y][x], heightDiffAboveOutside * edgeDrainageRate);
                            water[y][x] -= amountToDrain;
                            water[y][x] = Math.max(0, water[y][x]);
                        }
                    }
                }
            }

            // 6. Relajación/Difusión simplificada (reducimos iteraciones)
            const relaxationIterations = optimizationMode === 'high_rain' ? 1 : 2;
            const relaxationFactor = 0.05;

            for (let iter = 0; iter < relaxationIterations; iter++) {
                let heightChanges = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));

                for (let y = 1; y < gridSize - 1; y++) {
                    for (let x = 1; x < gridSize - 1; x++) {
                        const currentTotalHeight = terrain[y][x] + water[y][x];
                        let totalNeighborTotalHeight = 0;
                        let activeNeighborsCount = 0;

                        const directNeighbors = [
                            { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
                        ];

                        for (const neighbor of directNeighbors) {
                            const nx = x + neighbor.dx;
                            const ny = y + neighbor.dy;
                            const neighborTotalHeight = terrain[ny][nx] + water[ny][nx];
                            totalNeighborTotalHeight += neighborTotalHeight;
                            activeNeighborsCount++;
                        }

                        if (activeNeighborsCount > 0) {
                            const averageNeighborTotalHeight = totalNeighborTotalHeight / activeNeighborsCount;
                            const diff = averageNeighborTotalHeight - currentTotalHeight;
                            let transferAmount = diff * relaxationFactor;
                            heightChanges[y][x] += transferAmount;
                        }
                    }
                }

                for (let y = 1; y < gridSize - 1; y++) {
                    for (let x = 1; x < gridSize - 1; x++) {
                        water[y][x] += heightChanges[y][x];
                        water[y][x] = Math.max(0, water[y][x]);
                    }
                }
            }

            // 7. Actualización y Difusión de Humedad
            const humidityUpdateRate = 0.05;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (water[y][x] > 0.1) {
                        humidity[y][x] = Math.min(5, humidity[y][x] + humidityUpdateRate);
                    } else {
                        humidity[y][x] = Math.max(1, humidity[y][x] - humidityUpdateRate);
                    }
                }
            }

            // Update total water
            calculateTotalWater();
            updateWaterBalanceIndicator();
            updateDashboard();
            
            // Rendimiento: Actualizar contador FPS
            updateFPS();
            drawGrid();
        }

        // Función para calcular FPS
        function updateFPS() {
            const now = performance.now();
            frameCount++;
            
            if (now >= lastFpsUpdate + 1000) {
                fpsCounter.textContent = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
            }
        }

        // Función para calcular el agua total en el sistema
        function calculateTotalWater() {
            totalWater = 0;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    totalWater += water[y][x];
                }
            }
        }

        // Función para actualizar el indicador de balance agua/evaporación
        function updateWaterBalanceIndicator() {
            const waterChange = totalWater - previousTotalWater;

            if (waterChange < -0.1) {
                waterBalanceElement.textContent = "Evaporando (" + waterChange.toFixed(2) + ")";
                waterBalanceElement.className = "balance-value evaporating";
            } else if (waterChange > 0.1) {
                waterBalanceElement.textContent = "Acumulando (+" + waterChange.toFixed(2) + ")";
                waterBalanceElement.className = "balance-value accumulating";
            } else {
                waterBalanceElement.textContent = "Balanceado";
                waterBalanceElement.className = "balance-value balanced";
            }
        }

        // --- Funciones para gestionar Asentamientos ---
        function getRandomSettlementName() {
            if (availableNames.length === 0) {
                availableNames = [...settlementNames];
            }
            const randomIndex = Math.floor(Math.random() * availableNames.length);
            const name = availableNames[randomIndex];
            availableNames.splice(randomIndex, 1);
            return name;
        }

        function placeRandomSettlements() {
            settlements = [];
            availableNames = [...settlementNames];
            const maxAttempts = gridSize * gridSize * 2;
            let placedCount = 0;

            for (let i = 0; i < maxAttempts && placedCount < MAX_SETTLEMENTS; i++) {
                const x = Math.floor(Math.random() * gridSize);
                const y = Math.floor(Math.random() * gridSize);

                const currentHeight = terrain[y][x];
                const minHeightForSettlement = 15;
                const maxHeightForSettlement = 75;

                if (currentHeight < minHeightForSettlement || currentHeight > maxHeightForSettlement) {
                    continue;
                }

                let totalSlope = 0;
                let slopeNeighbors = 0;
                const slopeCheckRadius = 1;
                for (let dy = -slopeCheckRadius; dy <= slopeCheckRadius; dy++) {
                    for (let dx = -slopeCheckRadius; dx <= slopeCheckRadius; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
                            totalSlope += Math.abs(currentHeight - terrain[ny][nx]);
                            slopeNeighbors++;
                        }
                    }
                }
                const averageSlope = slopeNeighbors > 0 ? totalSlope / slopeNeighbors : 0;
                const maxAllowedSlope = 10;

                if (averageSlope > maxAllowedSlope) {
                    continue;
                }

                let tooClose = false;
                const minDistance = 5;
                for (const existingSettlement of settlements) {
                    const dist = Math.sqrt(Math.pow(x - existingSettlement.x, 2) + Math.pow(y - existingSettlement.y, 2));
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) {
                    continue;
                }

                settlements.push({ x, y, name: getRandomSettlementName() });
                placedCount++;
            }
        }

        // --- Funciones del Dashboard ---
        function updateDashboard() {
            const noSettlementMessage = document.getElementById('noSettlementSelectedMessage');
            const infoDiv = document.getElementById('settlementInfo');
            const nameSpan = document.getElementById('dashboardSettlementName');
            const floodSpan = document.getElementById('dashboardFloodRisk');
            const heightSpan = document.getElementById('dashboardHeight');
            const waterSpan = document.getElementById('dashboardWater');

            if (selectedSettlement) {
                noSettlementMessage.style.display = 'none';
                infoDiv.style.display = 'block';
                nameSpan.textContent = selectedSettlement.name;

                const sx = selectedSettlement.x;
                const sy = selectedSettlement.y;
                const settlementWaterAmount = water[sy][sx];

                let floodRiskText = 'Bajo';
                let floodRiskClass = 'low-risk';
                if (settlementWaterAmount >= 10) {
                    floodRiskText = 'Muy Alto';
                    floodRiskClass = 'very-high-risk';
                } else if (settlementWaterAmount >= 5) {
                    floodRiskText = 'Alto';
                    floodRiskClass = 'high-risk';
                } else if (settlementWaterAmount >= 1) {
                    floodRiskText = 'Moderado';
                    floodRiskClass = 'moderate-risk';
                }
                floodSpan.textContent = floodRiskText;
                floodSpan.className = `risk-indicator ${floodRiskClass}`;

                heightSpan.textContent = terrain[sy][sx].toFixed(1);
                waterSpan.textContent = settlementWaterAmount.toFixed(2);

            } else {
                noSettlementMessage.style.display = 'block';
                infoDiv.style.display = 'none';
            }
        }

        // --- Interacción del Usuario (Selección de Asentamientos) ---
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            let clickedSettlementFound = false;
            const clickRadius = cellSize * 0.7;

            for (const settlement of settlements) {
                const settlementCenterX = settlement.x * cellSize + cellSize / 2;
                const settlementCenterY = settlement.y * cellSize + cellSize / 2;

                const distance = Math.sqrt(
                    Math.pow(clickX - settlementCenterX, 2) +
                    Math.pow(clickY - settlementCenterY, 2)
                );

                if (distance <= clickRadius) {
                    selectedSettlement = settlement;
                    clickedSettlementFound = true;
                    break;
                }
            }

            if (!clickedSettlementFound) {
                selectedSettlement = null;
            }
            updateDashboard();
            drawGrid();
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Funciones de Control de la Simulación ---
        function toggleSimulation() {
            if (simulationRunning) {
                clearInterval(simulationInterval);
                simulationInterval = null;
                simulationRunning = false;
                toggleButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
                        <path d="m11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                    </svg>
                    Iniciar Simulación
                `;
                toggleButton.classList.remove('stop');
            } else {
                simulationInterval = setInterval(updateSimulation, simSpeed);
                simulationRunning = true;
                toggleButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
                        <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/>
                    </svg>
                    Detener Simulación
                `;
                toggleButton.classList.add('stop');
            }
        }

        function resetSimulation() {
            if (simulationRunning) {
                toggleSimulation();
            }

            timeWithoutRain = 0;
            evaporationMultiplier = 1.0;
            selectedSettlement = null;
            initGrid();
            drawGrid();
            updateDashboard();
            updateWaterBalanceIndicator();
        }

        // Configurar eventos
        toggleButton.addEventListener('click', toggleSimulation);
        resetButton.addEventListener('click', resetSimulation);

        // --- Configuración Inicial al Cargar la Página ---
        initGrid();
        drawGrid();
        updateDashboard();
        toggleSimulation();
    </script>
</body>
</html>